
// External libraries //
MiddleClass 	- https://github.com/kikito/middleclass/wiki
Hump (timer)	- http://vrld.github.io/hump/

// Load resources //
resource.getImage( image_file, wrap )
resource.getSound( sound_file, stype )
resource.getImageDimensions( image_file )

// Level management //
Level:createEntity( class, ... )
Level:removeEntity( ent )
Level:getEntitiesByClass( class )
Level:getEntitiesByMixin( mixin )
Level:getCamera()
Level:getPhysicsWorld()

// GUI //
GUI:addSimpleElement( depth, pos, image_file, id )
GUI:addDynamicElement( depth, pos, func, id )

// Vector math //
vec Vector:copy()
num Vector:distance( vec )
num Vector:distance2( vec )
num Vector:length()
num Vector:angle()
vec Vector:snap( gridsize )		-- modifies self
vec Vector:approach( vec, step )	-- modifies self
vec Vector:perpendicular()
num Vector:dot( vec )
num Vector:cross( vec )
vec Vector:projectOn( vec )
vec Vector:mirrorOn( vec )
vec Vector:normalize()			-- modifies self
vec Vector:getNormalized() / getNormal()
vec Vector:trim( maxLength )		-- modifies self
vec Vector:getTrimmed( maxLength )
vec Vector:rotate( r ) 			-- modifies self
vec Vector:getRotated( r )
vec Vector:multiplyBy( a )		-- modifies self
vec Vector:divideBy( a )		-- modifies self
vec Vector:add( vec )			-- modifies self
vec Vector:subtract( vec )		-- modifies self

// Extended table functions //
tab table.copy(t, lookup_table)		-- fully copies table including nested tables
tab table.clone(t)			-- copies base table, but not nested tables (references original tables)
bool table.hasValue( t, val )
mix table.keyFromValue( tbl, val )	-- returns key of first occurence value
mix table.removeByValue( tbl, val )	-- removes single occurence of value from table, returns original key
tab table.getKeys(t)			-- get all keys in the table
tab table.shuffle(t)			-- shuffles key - value combinations
tab table.forEach( t, func, ... ) 	-- if func is a function, then do func( key, value, ... ) on every table entry
					-- or if func is a string, do entry_value:func( ... ) on every table entry
num table.count( t, count_func ) 	-- if count_func(key, value) is supplied, only count where it returns true
mix table.random( t )			-- get random value
tab table.filter( t, func, retainkeys ) -- filter t where func(key, value) returns true
tab table.merge(t1, t2, retainkeys) 	-- merges t2 into t1, when retaining keys, t2 overwrites t1 keys
str table.toString( t, name, nice_formatting, [maxdepth], [maxseq] ) -- summarizes (sub)tables longer than maxseq, or deeper nested than maxdepth

// Extended string functions //
tab	string.split(str, [sep])	-- splits on space if seperator not provided
str	string.trim(str, [chars]) 	-- trims whitespace if chars not set
str	string.simpleFormat(str, ...)	-- string.simpleFormat("{b} hi {a}", {a = "mark", b = "Oh"}) -- Returns "Oh hi mark"
					-- string.simpleFormat("Hello {1}!", "world") -- Returns "Hello world!"

// Extended math functions //

num	math.distance( x1, y1, x2, y2 )
num	math.clamp( num, low, high )
num	math.randomRange( low, high )		-- returns float between low and high
num	math.sign( x )				-- returns 1 or -1 depending on if x is negative
num	math.round( i, [decimals] )		-- rounds to the specified number of decimals (default 0)
num	math.approach( cur, target, inc ) 	-- sets <inc> step from <cur> to <target>
num	math.lerp(a, b, frac) 			-- <frac> is in the range of 0 to 1
num	math.smooth(a, b, frac) 		-- same as math.lerp but with cosine interpolation
num	math.normalizeAngle( a )		-- normalizes angle to be between pi and -pi radians
num	math.angleDifference( a, b )
num	math.approachAngle( cur, target, inc )

// Extended package functions //
package.load(table)		-- loads swappable lua modules. Table in format { { module_name = "path_to_module" }, ... }
package.hotswap(module_ref)	-- hotswaps given module reference while game is running. Awesome feature.

// Extended debug functions //
debug.printLoadedPackages()	-- prints list of everything in packages.loaded

// Sprites //
Sprite( { (img) image, (vec) offset, (vec) size (default = image size), (vec) origin_pos, 
	  (vec) origin_relative (overrides origin_pos and sets it to origin_relative * size, so (0.5, 0.5) means center of image),
	  (num) num_frames, (num) fps, (bool) should_loop } )

// Input controller //

bool InputController:keyIsPressed(key)
bool InputController:keyIsReleased(key)
bool InputController:mouseIsPressed(button) -- l, r, m, wd, wu, x1, x2
bool InputController:mouseIsReleased(button)
bool InputController:keyIsDown(key)
bool InputController:mouseIsDown(button)

void InputController:addKeyPressCallback(id, key, func) -- callback = func(key)
void InputController:addKeyReleaseCallback(id, key, func) -- callback = func(key, timediff)
void InputController:addMousePressCallback(id, button, func) -- callback = func(button)
void InputController:addMouseReleaseCallback(id, button, func) -- callback = func(button, timediff)

void InputController:removeKeyPressCallback(id)
void InputController:removeKeyReleaseCallback(id)
void InputController:removeMousePressCallback(id)
void InputController:removeMouseReleaseCallback(id)

// Util functions //
util.getPathFromFilename( file_path, [seperator] )
util.choose( ... )
util.weightedChoice( ... ) 	-- in format util.weightedChoice("duck", 20, "cat", 10). "duck" is twice as likely to be chosen
util.array(...)			-- util.array(pairs({a = 1, b = 2})) -- Returns {"a", "b"}
util.equalsAll(value, ...)
util.equalsAny(value, ...)
util.lua( str ) 		-- runs the given string

// Color class //
Color:toHex()		-- Example: Color.Red:toHex() returns "FF0000"
Color:getTable()	-- returns { r, g, b, a }
Color:unpack()		-- returns r, g, b, a
Color:negative()	-- modifies self
Color:invert()		-- modifies self
Color:getHSV()		-- returns h, s, v, a in [0, 255] range
Color.fromHex( hex )	-- returns new Color
Color.fromHSV(h, s, v, a) -- returns new Color

// Signals and slots //
signal.new() 						-- returns new signal register table
signal.register( signal, function )			-- register function to execute when signal is emitted
signal.emit( signal, ... (func params) )		-- triggers signal with the given parameters
signal.emit_pattern( signal_pattern, ... (func params) ) -- triggers all matched signals (http://www.lua.org/manual/5.1/manual.html#5.4.1)
signal.remove( signal, ... (funcs to remove) ) 		-- removes function(s) from stated signal
signal.remove_pattern( signal_pattern, ... (funcs to remove) )
signal.clear( signal ) 					-- clears the whole signal
signal.clear_pattern( signal )

// Timers //
timer 	timer.new()					-- create new timer instance
handle 	timer.add(delay, function)			-- trigger <function>() after <delay>
handle	timer.addPeriodic(delay, function, [count])	-- trigger <function>() every <delay>, for <count> times (infinite if <count> = 0)
handle	timer.do_for(delay, function, [after])		-- executes <function>(dt) every update step for the next <delay> seconds. After that it calls <after>()
void	timer.cancel(handle)				-- removes the function that is linked to the listed <handle>
void	timer.clear()					-- clears whole timer
void	timer.update(dt)				-- update the timer
handle	timer.tween(duration, subject, target, [method], [after], ...)
							-- duration: duration of the tween
							-- subject: reference to a table
							-- target: target key-values to tween in the subject table
							-- method: default 'linear'. See Tweening Methods: http://vrld.github.io/hump/#hump.timerTweening_methods
							-- after: function to execute when duration has passed
TWEENING EXAMPLE:
	circle = {rad = 10, pos = {x = 400, y = 300}}
    	-- multiple tweens can work on the same subject
   	-- and nested values can be tweened, too
   	Timer.tween(5, circle, {rad = 50}, 'in-out-quad')
    	Timer.tween(2, circle, {pos = {y = 550}}, 'out-bounce')

// Gamestate //
gamestate.set( gamestate, ... )		-- pops entire stack and sets this gamestate
gamestate.push( gamestate, ... )	-- pushes gamestate on top of stack
gamestate.pop()
gamestate.switch( gamestate, ... )	-- swaps gamestate on top of stack with this one
gamestate.current()			-- returns table of current gamestate
gamestate.drawStack()			-- calls draw() function on every gamestate in the stack (ascending order)
gamestate.printStack()			-- debug print stack

// Advanced math / trigonometry / geometry //
mlib readme: https://github.com/davisdude/mlib/blob/master/README.md

// Rich text //
tlib: http://love2d.org/forums/viewtopic.php?f=5&t=76960

EXAMPLE:
---- Init
textref = tlib.new( '{white}White, {red}Red, {font}{blue}Blue{white} {pic}.', {
      x = 0,  y = 32, 
      red = { 255, 0, 0, 255 }, --declare all the other things with '{' '}' around them. Make sure they are spelled the same.
      blue = Color.Blue:getTable(), -- use own Color class
      white = Color.White:getTable(), 
      pic = love.graphics.newImage( 'pics/pic.png' ), 
      font = love.graphics.newFont( 'fonts/font.ttf' ), 
   } )

---- Draw
tlib.draw(textref)

